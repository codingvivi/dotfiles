#!/usr/bin/env nu

let yaml_path = "{{ .chezmoi.sourceDir }}/.chezmoidata/packages.yaml"

# ── distro detection ──────────────────────────────────────────────────────────

let os_id = (open /etc/os-release
    | lines
    | parse "{key}={value}"
    | where key == "ID"
    | first
    | get value
    | str trim --char '"')

let distro = match $os_id {
    "opensuse-tumbleweed" | "opensuse-leap" | "opensuse" => "opensuse"
    "fedora" | "fedora-asahi-remix" => "fedora"
    _ => { error make {msg: $"Unsupported distro: ($os_id)"} }
}

# ── package resolution ────────────────────────────────────────────────────────

# Resolves a single YAML entry against the current distro.
# Returns a normalized record, or null if the entry should be skipped.
def resolve [distro: string] {
    let entry = $in

    # Normalize: plain string → minimal record

    let base = match ($entry | describe) {
      "string" => {name: $entry}
      _ => $entry
    }

    # Get this distro's override block (null if absent)
    let distro_block = $base | get -o $distro

    # Check if any distro block claims exclusive ownership
    let has_exclusive = (
        ["opensuse" "fedora"]
        | any {|d| ($d in $base) and (($base | get $d | get -o install) == "exclusive") }
    )

    let this_install = if $distro_block != null { $distro_block | get -o install } else { null }

    let skip = ($this_install == "ignore") or ($has_exclusive and $this_install != "exclusive")

    if not $skip {
        # Merge distro block over base, then strip all meta keys
        let merged = if $distro_block != null { $base | merge $distro_block } else { $base }
        let cleaned = (
            ["opensuse" "fedora" "install"]
            | reduce -f $merged {|k, acc |
                match ($k in $acc) {
                    true => { $acc | reject $k }
                    _ => $acc
                }
            }
        )

        # Apply defaults for omitted fields
        let via   = $cleaned | get -o via   | default "pkg"
        let bin   = $cleaned | get -o bin   | default $cleaned.name
        let pkg   = $cleaned | get -o pkg   | default $cleaned.name
        let check = $cleaned | get -o check | default (if $via == "pkg" { "rpm" } else { "which" })

        $cleaned | merge {via: $via, check: $check, bin: $bin, pkg: $pkg}
    }
}

# ── load and resolve ──────────────────────────────────────────────────────────

print $"detecting distro: ($distro)"

let packages = (open $yaml_path).packages
    | each {|e| $e | resolve $distro}
    | compact

print $"resolved ($packages | length) packages for ($distro)"

# ── install functions ─────────────────────────────────────────────────────────

def not-installed [] {
    $in | where {|p|
        match $p.check {
            "rpm"   => { (^rpm -q $p.pkg | complete).exit_code != 0 }
            "which" => { which $p.bin | is-empty }
        }
    }
}

def install-pkg [distro: string] {
    let pkgs = $in

    # Packages without a repo: batch check → single install call
    let missing = $pkgs | where {|p| ($p | get -o repo) == null} | not-installed | get pkg

    if ($missing | is-not-empty) {
        print $"  pkg: installing ($missing | length) missing: ($missing | str join ', ')"
        match $distro {
            "opensuse" => { sudo zypper install ...$missing }
            "fedora"   => { sudo dnf install -y --skip-unavailable --skip-broken ...$missing }
        }
    } else {
        print "  pkg: all packages already installed"
    }

    # Packages with a repo: filter to uninstalled, add repo + install individually
    $pkgs
        | where {|p| ($p | get -o repo) != null}
        | not-installed
        | each {|p|
            print $"  pkg+repo: installing ($p.name)..."
            try { sudo zypper addrepo --refresh $p.repo }
            sudo zypper refresh
            sudo zypper --non-interactive install $p.pkg
        }
}

def install-args [] {
    let p = $in
    match ($p | get -o args) {
        null => [$p.name]
        _ => $p.args
    }
}

def install-tool [via: string] {
    $in
        | not-installed
        | each {|p|
            print $"  ($via): installing ($p.name)..."
            let args = $p | install-args
            match $via {
                "cargo" => { ^cargo install ...$args }
                "uv"    => { ^uv tool install ...$args }
                "go"    => { ^go install ...$args }
                "mise"  => { ^mise use -g ...$args }
            }
        }
}

# ── main ──────────────────────────────────────────────────────────────────────

print "── pkg ──────────────────────────────────────────"
$packages | where via == "pkg"   | install-pkg $distro

print "── cargo ────────────────────────────────────────"
$packages | where via == "cargo" | install-tool "cargo"

print "── uv ───────────────────────────────────────────"
$packages | where via == "uv"    | install-tool "uv"

print "── go ───────────────────────────────────────────"
$packages | where via == "go"    | install-tool "go"

print "── mise ─────────────────────────────────────────"
$packages | where via == "mise"  | install-tool "mise"

print "── done ─────────────────────────────────────────"
